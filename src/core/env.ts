import path from "path";
import type { InstanceState, ResolvedConfig } from "./types";
import { writeLockfile } from "./lockfile";
import { logger } from "../utils/logger";

const toEnvLine = (key: string, value: string | number): string =>
  `${key}=${String(value)}`;

export const buildEnvVars = (state: InstanceState, urls: Record<string, string>): Record<string, string> => {
  const env: Record<string, string> = {
    WORKSPACE_NAME: state.identity.name,
    COMPOSE_PROJECT_NAME: state.identity.composeName,
    DOCKER_NETWORK: state.identity.dockerNetwork,
    VOLUME_PREFIX: state.identity.volumePrefix,
    CONTAINER_PREFIX: state.identity.containerPrefix,
  };

  if (state.profile) {
    env.SILO_PROFILE = state.profile;
  }

  Object.entries(state.identity.hosts).forEach(([key, value]) => {
    env[key] = value;
  });

  Object.entries(state.ports).forEach(([key, value]) => {
    env[key] = String(value);
  });

  if (state.identity.k3dClusterName) {
    env.K3D_CLUSTER_NAME = state.identity.k3dClusterName;
  }
  if (state.identity.k3dRegistryName) {
    env.K3D_REGISTRY_NAME = state.identity.k3dRegistryName;
  }
  if (state.identity.kubeconfigPath) {
    env.KUBECONFIG = state.identity.kubeconfigPath;
  }

  Object.entries(urls).forEach(([key, value]) => {
    env[key] = value;
  });

  return env;
};

const renderEnvFile = (params: {
  state: InstanceState;
  config: ResolvedConfig;
  urls: Record<string, string>;
  hostOrder: string[];
  portOrder: string[];
  urlOrder: string[];
}): string => {
  const { state, config, urls, hostOrder, portOrder, urlOrder } = params;
  const generatedAt = new Date().toISOString();
  const lines: string[] = [];

  lines.push("# Generated by silo");
  lines.push(`# Instance: ${state.name}`);
  lines.push(`# Generated: ${generatedAt}`);
  lines.push("");

  lines.push("# === Instance Identity ===");
  lines.push(toEnvLine("WORKSPACE_NAME", state.identity.name));
  lines.push(toEnvLine("COMPOSE_PROJECT_NAME", state.identity.composeName));
  lines.push(toEnvLine("DOCKER_NETWORK", state.identity.dockerNetwork));
  lines.push(toEnvLine("VOLUME_PREFIX", state.identity.volumePrefix));
  lines.push(toEnvLine("CONTAINER_PREFIX", state.identity.containerPrefix));
  if (state.profile) {
    lines.push(toEnvLine("SILO_PROFILE", state.profile));
  }
  lines.push("");

  lines.push("# === Hosts (browser isolation) ===");
  hostOrder.forEach((key) => {
    const value = state.identity.hosts[key];
    if (value !== undefined) {
      lines.push(toEnvLine(key, value));
    }
  });
  lines.push("");

  lines.push("# === Allocated Ports ===");
  portOrder.forEach((key) => {
    const value = state.ports[key];
    if (value !== undefined) {
      lines.push(toEnvLine(key, value));
    }
  });
  lines.push("");

  if (config.k3d?.enabled) {
    lines.push("# === k3d (if enabled) ===");
    if (state.identity.k3dClusterName) {
      lines.push(toEnvLine("K3D_CLUSTER_NAME", state.identity.k3dClusterName));
    }
    if (state.identity.k3dRegistryName) {
      lines.push(toEnvLine("K3D_REGISTRY_NAME", state.identity.k3dRegistryName));
    }
    if (state.identity.kubeconfigPath) {
      lines.push(toEnvLine("KUBECONFIG", state.identity.kubeconfigPath));
    }
    lines.push("");
  }

  if (urlOrder.length > 0) {
    lines.push("# === Derived URLs ===");
    urlOrder.forEach((key) => {
      const value = urls[key];
      if (value !== undefined) {
        lines.push(toEnvLine(key, value));
      }
    });
    lines.push("");
  }

  return `${lines.join("\n")}\n`;
};

export const resolveEnvPath = (config: ResolvedConfig): string =>
  path.resolve(config.projectRoot, config.output);

export const writeEnvAndLockfile = async (params: {
  state: InstanceState;
  config: ResolvedConfig;
  urls: Record<string, string>;
  hostOrder: string[];
  portOrder: string[];
  urlOrder: string[];
}): Promise<string> => {
  const { state, config, urls, hostOrder, portOrder, urlOrder } = params;
  const envPath = resolveEnvPath(config);
  const envContent = renderEnvFile({
    state,
    config,
    urls,
    hostOrder,
    portOrder,
    urlOrder,
  });

  await Bun.write(envPath, envContent);
  await writeLockfile(config.projectRoot, state);

  logger.info(`Generated env file at ${envPath}`);
  logger.info("Wrote lockfile");

  return envPath;
};
